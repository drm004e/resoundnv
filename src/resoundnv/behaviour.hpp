//    Resound
//    Copyright 2009 David Moore and James Mooney
//
//    This file is part of Resound.
//
//    Resound is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    Resound is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with Resound; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#pragma once
#include "resound_types.hpp"

class AudioStream;
class Loudspeaker;

// an actual dsp route, created by parsing the routing cass/cls "language"
class BRoute{
	AudioBuffer* fromBuffer_;
	AudioBuffer* toBuffer_;
	float gain_;
	void* userData_; ///< allow the behaviour to store some aribitrary info
public:
	BRoute() : fromBuffer_(0), toBuffer_(0), gain_(1.0f), userData_(0) {}
	BRoute(AudioBuffer* fromBuffer, AudioBuffer* toBuffer, float gain) :
			fromBuffer_(fromBuffer), toBuffer_(toBuffer) , gain_(gain), userData_(0)
			{}
	AudioBuffer* get_from() const {return fromBuffer_;}
	AudioBuffer* get_to() const {return toBuffer_;}
	float get_gain() const {return gain_; }
	void* get_user_data() const { return userData_; }
	void set_user_data(void* userData) { userData_=userData; }
};

typedef std::vector<BRoute> BRouteArray; // sequential array of routes

// routes are stored in behaviours
class BRouteSet{

private:
	BRouteArray routes_;
public:
	BRouteSet(const xmlpp::Node* node);
	BRouteArray& get_routes() {return routes_; }
        /// creates a route from 2 buffer ref structures
        void create_route(const BufferRef& a, const BufferRef& b, float gain);
};

// parameters for behaviours
class BParam{
	float value_;
	std::string addr_;
public:
	BParam();
	void init_from_xml(const xmlpp::Element* nodeElement);
	float get_value(){ return value_; }
	ObjectId get_address(){return addr_;}
	// callback for osc
	static int lo_cb_params(const char *path, const char *types, lo_arg **argv, int argc, void *data, void *user_data);
};

/// A dsp pluginable object abstract class generated by factory
class Behaviour : public DynamicObject {
public:
	typedef std::map<ObjectId,BParam*> BParamMap;
        typedef std::vector<AudioBuffer*> BufferVector;

private:
	BParamMap params_;
        BufferVector buffers_;
public:
	Behaviour();
        virtual ~Behaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);

	/// abstract virtualised dsp call
	/// class is expected to copy from input stream buffers to loudspeaker buffers.
	/// some processing would occur on the way
	virtual void process(jack_nframes_t nframes) = 0;

	/// register a parameter:
	/// this should be called in a constructor or init function prior to loading base class xml
	void register_parameter(ObjectId id, BParam* param);
	/// obtain a parameter value
	// TODO this should really be some sort of fast lookup table pre-built at the start of dsp.
	float get_parameter_value(const char* name){ return params_[name]->get_value(); }

        /// create a buffer and register it with the session
        void create_buffer(ObjectId subId="");
        /// get a buffer by index
        AudioBuffer& get_buffer(int n) { return *buffers_[n]; }
};

/// a stream - a wrapper around an available input buffer
class Diskstream : public Behaviour {
	jack_ringbuffer_t* ringBuffer_; ///< a ring buffer is used to ensure non-locking thread safe read
	static const size_t DISK_STREAM_RING_BUFFER_SIZE = 4096;
	float* diskBuffer_;
	float* copyBuffer_;
	SNDFILE* file_;
	SF_INFO info_;
	std::string path_;
	bool playing_;
        float gain_;
public:

	/// construct
	Diskstream();
	void init_from_xml(const xmlpp::Element* nodeElement);

	/// destruct
	virtual ~Diskstream();

	/// class is expected to pull as much data as it can from disk into the ring buffer
	/// this is called from a disk reading thread
	virtual void disk_process();

	/// class is expected to make its next buffer of audio ready. read a block from the ringbuffer
	virtual void process(jack_nframes_t nframes);

	/// method to seek the current disk location, lock thread mutex first!
	void seek(size_t pos);

	/// start this stream, lock disk thread mutex first!
	void play();
	/// stop this stream, lock disk thread mutex first!
	void stop();

        static Behaviour* factory() { return new Diskstream(); }
};

/// a stream - a wrapper around an available input buffer
class Livestream : public Behaviour{
	JackPort* port_;
	std::string connectionName_;
        float gain_;
public:

	Livestream();
	void init_from_xml(const xmlpp::Element* nodeElement);
	/// class is expected to make its next buffer of audio ready.
	virtual void process(jack_nframes_t nframes);

        static Behaviour* factory() { return new Livestream(); }
};

/// A dsp pluginable object abstract class generated by factory
/// this version is extended to deal with routeset interpretation
/// route are created automatically and the behaviour dsp can access these easily
/// this version should be used as a base for certain behaviours that work with CASS and CLS sets
class RouteSetBehaviour : public Behaviour {
public:
	typedef std::vector<BRouteSet*> BRouteSetArray; // sequential array of routes
private:
	BRouteSetArray routeSets_;
public:
	RouteSetBehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);

	virtual void process(jack_nframes_t nframes) = 0;
	BRouteSetArray& get_route_sets() {return routeSets_;}
};

/// an IOBehaviour does not use the routeset interpretation and instead suggests inputs and outputs
/// routing must be entirely handled by the behaviour dsp.
class IOBehaviour : public Behaviour {
public:
	typedef std::vector<AudioBuffer*> BufferArray;
	typedef std::vector<Loudspeaker*> LoudspeakerArray;
private:
	BufferArray inputs_;
	LoudspeakerArray outputs_;
public:
	IOBehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);

	virtual void process(jack_nframes_t nframes) = 0;
	BufferArray& get_inputs() {return inputs_;}
	LoudspeakerArray& get_outputs() {return outputs_;}
};

/// A dsp pluginable object abstract class generated by factory
class MinimalRouteSetBehaviour : public RouteSetBehaviour {
public:

	MinimalRouteSetBehaviour(){
		std::cout << "Created minimal routeset behaviour object!" << std::endl;
	}
	virtual void process(jack_nframes_t nframes){};
	static Behaviour* factory() { return new MinimalRouteSetBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class AttBehaviour : public RouteSetBehaviour {
public:

	AttBehaviour(){
		std::cout << "Created Att routeset behaviour object!" << std::endl;
	}

	virtual void process(jack_nframes_t nframes);
	static Behaviour* factory() { return new AttBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class MultipointCrossfadeBehaviour : public RouteSetBehaviour {
	float position_, gain_, slope_;
	LookupTable* hannFunction;
	static const size_t HANN_TABLE_SIZE=512;
	float *oldGains_; ///< used for interpolation algorithm
public:

	MultipointCrossfadeBehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);

	virtual void process(jack_nframes_t nframes);
	static Behaviour* factory() { return new MultipointCrossfadeBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class ChaseBehaviour : public RouteSetBehaviour {
	float freq_, phase_, gain_, slope_;
	LookupTable* hannFunction;
	static const size_t HANN_TABLE_SIZE=512;
	float *oldGains_; ///< used for interpolation algorithm
	Phasor phasor;
public:

	ChaseBehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);
	virtual void process(jack_nframes_t nframes);
	static Behaviour* factory() { return new ChaseBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class MinimalIOBehaviour : public IOBehaviour {
public:

	MinimalIOBehaviour(){
		std::cout << "Created minimal io based behaviour object!" << std::endl;
	}
	virtual void process(jack_nframes_t nframes){};
	static Behaviour* factory() { return new MinimalIOBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class AmpPanBehaviour : public IOBehaviour {
	Vec3 pos_;
	float gain_;
	float* oldGains_;
public:
	AmpPanBehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);
	virtual void process(jack_nframes_t nframes);
	static Behaviour* factory() { return new AmpPanBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class GainInsertBehaviour : public IOBehaviour {
	float gain_;
public:
	GainInsertBehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);
	virtual void process(jack_nframes_t nframes);
	static Behaviour* factory() { return new GainInsertBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class RingmodInsertBehaviour : public IOBehaviour {
	float gain_;
        float freq_;
        Phasor phasor_;
        LookupTable* sinFunction_;
	static const size_t SIN_TABLE_SIZE=512;
public:
	RingmodInsertBehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);
	virtual void process(jack_nframes_t nframes);
	static Behaviour* factory() { return new RingmodInsertBehaviour(); }
};

/// A dsp pluginable object abstract class generated by factory
class LADSPABehaviour : public IOBehaviour {
	std::string plugName;
	const LADSPA_Descriptor *descriptor;
public:
	LADSPABehaviour();
	void init_from_xml(const xmlpp::Element* nodeElement);
	virtual void process(jack_nframes_t nframes);
	static Behaviour* factory() { return new LADSPABehaviour(); }
};

/// behaviours are created by factory function
typedef Behaviour* (*BehaviourFactory)();
